---
cover: https://image.acg.lol/file/2025/11/09/reimu-3.jpg
title: 接口隔离原则与合成复用原则在Spring中的应用
date: 2026-2-3 09:30:00
categories: 设计模式
excerpt: 本文详细介绍了接口隔离原则(ISP)和合成复用原则(CRP)在SpringBoot和SpringCloud中的应用实践，包括接口拆分、微服务接口隔离、组合替代继承、依赖注入实现组合等最佳实践，帮助开发者构建模块化、可维护的系统架构。
---


# 接口隔离原则(ISP)

接口隔离原则(Interface Segregation Principle, ISP)是SOLID原则中的第五个原则，它规定：客户端不应该被迫依赖于它不使用的方法。多个特定客户端接口要好于一个通用接口。

## 1. 核心概念
接口隔离原则的关键思想：

+ **不要强迫客户端依赖它们不需要的方法**
+ **将臃肿的接口拆分为更小、更具体的接口**
+ **让接口的职责单一化**
+ **避免"胖接口"(Fat Interface)**

## 2. SpringBoot中的应用方式
### 2.1 接口拆分示例
```java
// 违反ISP的反例 - 臃肿的接口
public interface UserService {
    // 用户基本操作
    UserDTO getUserById(Long id);
    List<UserDTO> getAllUsers();
    UserDTO createUser(UserCreateRequest request);
    UserDTO updateUser(Long id, UserUpdateRequest request);
    void deleteUser(Long id);
    
    // 管理员操作
    void resetPassword(Long userId);
    void lockUser(Long userId);
    void unlockUser(Long userId);
    List<UserDTO> getLockedUsers();
    
    // 认证授权操作
    boolean hasPermission(Long userId, String permission);
    Set<String> getUserPermissions(Long userId);
    void assignRole(Long userId, String role);
}

// 符合ISP的正确设计 - 拆分接口
public interface BasicUserService {
    UserDTO getUserById(Long id);
    List<UserDTO> getAllUsers();
    UserDTO createUser(UserCreateRequest request);
    UserDTO updateUser(Long id, UserUpdateRequest request);
    void deleteUser(Long id);
}

public interface AdminUserService {
    void resetPassword(Long userId);
    void lockUser(Long userId);
    void unlockUser(Long userId);
    List<UserDTO> getLockedUsers();
}

public interface AuthorizationService {
    boolean hasPermission(Long userId, String permission);
    Set<String> getUserPermissions(Long userId);
    void assignRole(Long userId, String role);
}
```

### 2.2 Spring中的具体实现
```java
// 具体实现类按需实现接口
@Service
@Transactional
public class UserServiceImpl implements BasicUserService, AdminUserService, AuthorizationService {
    
    @Override
    public UserDTO getUserById(Long id) {
        // 获取用户逻辑
        return new UserDTO();
    }
    
    @Override
    public List<UserDTO> getAllUsers() {
        // 获取所有用户逻辑
        return new ArrayList<>();
    }
    
    // 实现所有接口的方法...
}

// 普通控制器只需要基础服务
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final BasicUserService basicUserService;
    
    public UserController(BasicUserService basicUserService) {
        this.basicUserService = basicUserService;
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<UserDTO> getUser(@PathVariable Long id) {
        return ResponseEntity.ok(basicUserService.getUserById(id));
    }
}

// 管理员控制器需要管理功能
@RestController
@RequestMapping("/api/admin/users")
@PreAuthorize("hasRole('ADMIN')")
public class AdminUserController {
    
    private final BasicUserService basicUserService;
    private final AdminUserService adminUserService;
    
    public AdminUserController(BasicUserService basicUserService, 
                              AdminUserService adminUserService) {
        this.basicUserService = basicUserService;
        this.adminUserService = adminUserService;
    }
    
    @PostMapping("/{userId}/lock")
    public ResponseEntity<Void> lockUser(@PathVariable Long userId) {
        adminUserService.lockUser(userId);
        return ResponseEntity.ok().build();
    }
}
```

### 2.3 使用@Qualifier区分接口实现
```java
// 专门的管理员服务实现
@Service
@Qualifier("adminUserService")
public class AdminOnlyUserService implements AdminUserService {
    
    @Override
    public void resetPassword(Long userId) {
        // 管理员专用的密码重置逻辑
    }
    
    // 只实现AdminUserService接口的方法
}

// 认证服务实现
@Service
@Qualifier("authService")
public class AuthBasedAuthorizationService implements AuthorizationService {
    
    @Override
    public boolean hasPermission(Long userId, String permission) {
        // 基于权限的验证逻辑
        return true;
    }
    
    // 只实现AuthorizationService接口的方法
}
```

## 3. SpringCloud中的应用方式
### 3.1 微服务接口隔离
```java
// 订单服务的细粒度接口
public interface OrderQueryService {
    OrderDTO getOrderById(Long orderId);
    List<OrderDTO> getOrdersByUserId(Long userId);
    Page<OrderDTO> getOrdersWithPagination(Pageable pageable);
}

public interface OrderCommandService {
    OrderDTO createOrder(OrderCreateCommand command);
    OrderDTO updateOrderStatus(Long orderId, OrderStatus status);
    void cancelOrder(Long orderId);
}

public interface OrderPaymentService {
    PaymentResult processPayment(Long orderId, PaymentRequest paymentRequest);
    RefundResult processRefund(Long orderId, RefundRequest refundRequest);
}

// Feign客户端接口也遵循ISP
@FeignClient(name = "order-service")
public interface OrderQueryClient {
    
    @GetMapping("/orders/{id}")
    OrderDTO getOrderById(@PathVariable Long id);
    
    @GetMapping("/users/{userId}/orders")
    List<OrderDTO> getOrdersByUserId(@PathVariable Long userId);
}

@FeignClient(name = "order-service")
public interface OrderCommandClient {
    
    @PostMapping
    OrderDTO createOrder(@RequestBody OrderCreateCommand command);
    
    @PutMapping("/{orderId}/status")
    OrderDTO updateOrderStatus(@PathVariable Long orderId, 
                               @RequestParam OrderStatus status);
}
```

### 3.2 API网关路由隔离
```java
# application.yml
spring:
cloud:
gateway:
routes:
# 查询路由 - 只读权限
- id: order-query
uri: lb://order-service
predicates:
- Path=/api/orders/**
filters:
- name: RequestRateLimiter
args:
redis-rate-limiter.replenishRate: 100
redis-rate-limiter.burstCapacity: 200

# 命令路由 - 需要更高权限
- id: order-command
uri: lb://order-service
predicates:
- Path=/api/orders/command/**
filters:
- name: AuthFilter
args:
required-role: ADMIN
```

## 4. 最佳实践场景
### 4.1 角色基础接口设计
```java
// 基础读写接口
public interface ReadableRepository<T, ID> {
    Optional<T> findById(ID id);
    List<T> findAll();
    boolean existsById(ID id);
}

public interface WritableRepository<T, ID> {
    T save(T entity);
    <S extends T> List<S> saveAll(Iterable<S> entities);
    void deleteById(ID id);
    void delete(T entity);
}

// 组合接口
public interface CrudRepository<T, ID> extends ReadableRepository<T, ID>, WritableRepository<T, ID> {
}

// 业务特定的仓库接口
public interface AuditableRepository<T, ID> extends CrudRepository<T, ID> {
    List<T> findByCreatedDateAfter(LocalDateTime date);
    List<T> findByLastModifiedBy(String username);
}

// 具体实现按需扩展
@Repository
public class UserRepositoryImpl implements CrudRepository<User, Long>, AuditableRepository<User, Long> {
    // 实现所有必要的方法
}
```

### 4.2 事件监听器接口隔离
```java
// 不同类型的事件监听器接口
public interface OrderEventListener {
    void onOrderCreated(OrderCreatedEvent event);
    void onOrderCancelled(OrderCancelledEvent event);
}

public interface PaymentEventListener {
    void onPaymentSuccess(PaymentSuccessEvent event);
    void onPaymentFailed(PaymentFailedEvent event);
}

public interface InventoryEventListener {
    void onStockLow(StockLowEvent event);
    void onStockReplenished(StockReplenishedEvent event);
}

// 组合监听器
@Component
public class BusinessEventListener implements 
    OrderEventListener, PaymentEventListener, InventoryEventListener {
    
    @Override
    public void onOrderCreated(OrderCreatedEvent event) {
        // 处理订单创建事件
    }
    
    @Override
    public void onPaymentSuccess(PaymentSuccessEvent event) {
        // 处理支付成功事件
    }
    
    // 实现所有接口方法...
}

// 专门的库存监听器
@Component
public class InventoryOnlyListener implements InventoryEventListener {
    
    @Override
    public void onStockLow(StockLowEvent event) {
        // 只关心库存不足事件
        sendRestockAlert(event.getProductId());
    }
    
    @Override
    public void onStockReplenished(StockReplenishedEvent event) {
        // 只关心库存补充事件
        updateInventoryDashboard(event.getProductId());
    }
    
    private void sendRestockAlert(Long productId) {
        // 发送补货提醒
    }
    
    private void updateInventoryDashboard(Long productId) {
        // 更新仪表板
    }
}
```

### 4.3 配置服务接口隔离
```java
// 配置读取接口
public interface ConfigReader {
    String getString(String key);
    Integer getInt(String key);
    Boolean getBoolean(String key);
    <T> T getValue(String key, Class<T> type);
}

// 配置写入接口
public interface ConfigWriter {
    void setString(String key, String value);
    void setInt(String key, Integer value);
    void setBoolean(String key, Boolean value);
    <T> void setValue(String key, T value);
}

// 配置监听接口
public interface ConfigWatcher {
    void addListener(String keyPattern, ConfigChangeListener listener);
    void removeListener(String keyPattern);
}

// 组合配置服务接口
public interface ConfigService extends ConfigReader, ConfigWriter, ConfigWatcher {
}

// 只读配置服务（用于前端等场景）
@Service
@Qualifier("readOnlyConfigService")
public class ReadOnlyConfigService implements ConfigReader {
    
    @Autowired
    private ConfigService fullConfigService;
    
    @Override
    public String getString(String key) {
        return fullConfigService.getString(key);
    }
    
    // 只实现读取方法，编译时保证不会调用写入方法
}
```

## 5. 优势总结
1. **减少依赖**：客户端只依赖需要的方法，减少不必要的耦合
2. **提高灵活性**：可以独立修改和扩展各个接口
3. **增强可维护性**：接口职责单一，易于理解和维护
4. **改善编译时检查**：未实现的方法会在编译时报错
5. **更好的封装**：隐藏不需要暴露的功能

## 6. 实际项目中的ISP实践建议
1. **按功能域拆分大接口**
2. **使用Spring的@Qualifier区分不同实现**
3. **在微服务中按业务能力划分API**
4. **利用Java 8的默认方法适度扩展接口**
5. **定期重构检查接口的"肥胖度"**

```java
// 使用默认方法的适度扩展
public interface AdvancedUserService extends BasicUserService {
    
    @Override
    default UserDTO updateUser(Long id, UserUpdateRequest request) {
        // 提供默认的更新逻辑，具体实现可以覆盖
        UserDTO existing = getUserById(id);
        // 合并更新逻辑
        return mergeAndSave(existing, request);
    }
    
    private UserDTO mergeAndSave(UserDTO existing, UserUpdateRequest request) {
        // 默认合并保存逻辑
        return existing;
    }
}
```

在SpringBoot/SpringCloud中应用接口隔离原则，可以构建出更加模块化、可维护的微服务架构，每个服务、组件只暴露必要的接口，降低系统复杂度。


# 合成复用原则(CRP)

合成复用原则(Composite Reuse Principle, CRP)，也称为组合/聚合复用原则，它规定：尽量使用对象组合，而不是继承来达到复用的目的。

## 1. 核心概念 
合成复用原则的关键思想：

+ **优先使用组合(Composition)和聚合(Aggregation)而非继承(Inheritance)**
+ **组合表示"has-a"关系，继承表示"is-a"关系**
+ **通过依赖注入实现组合关系**
+ **降低类之间的耦合度，提高系统的灵活性**

## 2. SpringBoot中的应用方式
### 2.1 组合替代继承 
```java
// 违反CRP的反例 - 使用继承导致的问题
class OrderProcessor {
    public void process(Order order) {
        validate(order);
        calculateTotal(order);
        save(order);
    }

    protected void validate(Order order) { /* 基础验证 */ }
    protected void calculateTotal(Order order) { /* 基础计算 */ }
    protected void save(Order order) { /* 基础保存 */ }
}

// 特殊订单处理 - 继承导致的问题
class GroupOrderProcessor extends OrderProcessor {
    @Override
    protected void calculateTotal(GroupOrder order) {
        // 需要重新实现大部分逻辑，只是修改了计算方式
        // 违反了"is-a"关系，GroupOrderProcessor并不是一种OrderProcessor
        super.validate(order);
        // 团购特有的计算逻辑
        calculateGroupDiscount(order);
        super.save(order);
    }

    private void calculateGroupDiscount(GroupOrder order) {
        // 团购折扣计算
    }
}

// 符合CRP的正确设计 - 使用组合
class OrderProcessor {
    private final Validator validator;
    private final Calculator calculator;
    private final Saver saver;

    public OrderProcessor(Validator validator, Calculator calculator, Saver saver) {
        this.validator = validator;
        this.calculator = calculator;
        this.saver = saver;
    }

    public void process(Order order) {
        validator.validate(order);
        calculator.calculateTotal(order);
        saver.save(order);
    }
}

// 通过组合实现不同策略
@Component
public class StandardOrderProcessor {

    private final Validator standardValidator;
    private final Calculator standardCalculator;
    private final Saver standardSaver;

    public StandardOrderProcessor() {
        this.standardValidator = new StandardValidator();
        this.standardCalculator = new StandardCalculator();
        this.standardSaver = new DatabaseSaver();
    }

    // 或者通过依赖注入
    @Autowired
    public StandardOrderProcessor(Validator validator, Calculator calculator, Saver saver) {
        this.standardValidator = validator;
        this.standardCalculator = calculator;
        this.standardSaver = saver;
    }
}

@Component
public class GroupOrderProcessor {

    private final Validator groupValidator;
    private final Calculator groupCalculator;
    private final Saver groupSaver;

    public GroupOrderProcessor() {
        this.groupValidator = new GroupValidator();
        this.groupCalculator = new GroupCalculator();
        this.groupSaver = new DatabaseSaver(); // 可以复用保存逻辑
    }
}
```

### 2.2 Spring中的依赖注入实现组合 
```java
// 定义可组合的组件接口
public interface Logger {
    void log(String message);
}

public interface Cache {
    void put(String key, Object value);
    Object get(String key);
}

public interface MetricsCollector {
    void record(String metric, long value);
}

// 具体实现
@Component
public class FileLogger implements Logger {
    @Override
    public void log(String message) {
        System.out.println("File Log: " + message);
    }
}

@Component
public class RedisCache implements Cache {
    @Override
    public void put(String key, Object value) {
        System.out.println("Redis Cache PUT: " + key);
    }

    @Override
    public Object get(String key) {
        System.out.println("Redis Cache GET: " + key);
        return null;
    }
}

@Component
public class PrometheusMetrics implements MetricsCollector {
    @Override
    public void record(String metric, long value) {
        System.out.println("Metrics: " + metric + " = " + value);
    }
}

// 业务服务通过组合使用这些组件
@Service
public class UserService {

    private final UserRepository userRepository;
    private final Logger logger;
    private final Cache cache;
    private final MetricsCollector metrics;

    // 通过构造器注入所有需要的组件
    @Autowired
    public UserService(UserRepository userRepository, 
                       Logger logger, 
                       Cache cache,
                       MetricsCollector metrics) {
        this.userRepository = userRepository;
        this.logger = logger;
        this.cache = cache;
        this.metrics = metrics;
    }

    public UserDTO getUserById(Long id) {
        long startTime = System.currentTimeMillis();

        try {
            // 记录指标
            metrics.record("user.get.start", 1);

            // 尝试从缓存获取
            UserDTO cached = (UserDTO) cache.get("user:" + id);
            if (cached != null) {
                metrics.record("user.get.cache.hit", 1);
                logger.log("Cache hit for user: " + id);
                return cached;
            }

            // 从数据库获取
            UserDTO user = userRepository.findById(id)
            .orElseThrow(() -> new UserNotFoundException("User not found"));

            // 存入缓存
            cache.put("user:" + id, user);

            metrics.record("user.get.success", 1);
            logger.log("Retrieved user: " + id);

            return user;

        } catch (Exception e) {
            metrics.record("user.get.error", 1);
            logger.log("Error retrieving user: " + id + ", error: " + e.getMessage());
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            metrics.record("user.get.duration", duration);
        }
    }
}
```

### 2.3 动态组合与策略模式 
```java
// 支付策略接口
public interface PaymentStrategy {
    PaymentResult pay(PaymentRequest request);
    boolean supports(PaymentType type);
}

// 具体支付策略
@Component
public class AlipayStrategy implements PaymentStrategy {
    @Override
    public PaymentResult pay(PaymentRequest request) {
        System.out.println("Alipay payment processing...");
        return new PaymentResult(true, "Alipay success");
    }

    @Override
    public boolean supports(PaymentType type) {
        return PaymentType.ALIPAY == type;
    }
}

@Component
public class WechatPayStrategy implements PaymentStrategy {
    @Override
    public PaymentResult pay(PaymentRequest request) {
        System.out.println("Wechat Pay processing...");
        return new PaymentResult(true, "Wechat Pay success");
    }

    @Override
    public boolean supports(PaymentType type) {
        return PaymentType.WECHAT_PAY == type;
    }
}

// 支付服务通过组合多个策略
@Service
public class PaymentService {

    private final List<PaymentStrategy> paymentStrategies;

    // Spring会自动注入所有PaymentStrategy实现
    @Autowired
    public PaymentService(List<PaymentStrategy> paymentStrategies) {
        this.paymentStrategies = paymentStrategies;
    }

    public PaymentResult processPayment(PaymentRequest request) {
        // 根据支付类型选择合适的策略
        PaymentStrategy strategy = paymentStrategies.stream()
        .filter(s -> s.supports(request.getPaymentType()))
        .findFirst()
        .orElseThrow(() -> new UnsupportedPaymentTypeException("Unsupported payment type"));

        return strategy.pay(request);
    }

    // 动态添加新的支付策略
    public void addPaymentStrategy(PaymentStrategy strategy) {
        paymentStrategies.add(strategy);
    }
}
```

## 3. SpringCloud中的应用方式 
### 3.1 微服务功能的组合 
```java
// 定义微服务的能力接口
public interface CircuitBreaker {
    <T> T execute(Supplier<T> supplier, Supplier<T> fallback);
}

public interface RateLimiter {
    boolean allowRequest(String key, int limit);
}

public interface RetryPolicy {
    <T> T execute(Supplier<T> supplier);
}

public interface LoadBalancer {
    ServiceInstance choose(String serviceId);
}

// 具体实现
@Component
public class Resilience4jCircuitBreaker implements CircuitBreaker {
    private final CircuitBreakerRegistry registry = CircuitBreakerRegistry.ofDefaults();

    @Override
    public <T> T execute(Supplier<T> supplier, Supplier<T> fallback) {
        CircuitBreaker cb = registry.circuitBreaker("default");
        return cb.executeSupplier(supplier);
    }
}

@Component
public class RedisRateLimiter implements RateLimiter {
    @Override
    public boolean allowRequest(String key, int limit) {
        // Redis限流逻辑
        return true;
    }
}

// 微服务客户端组合多种能力
@Service
public class ResilientServiceClient {

    private final RestTemplate restTemplate;
    private final CircuitBreaker circuitBreaker;
    private final RateLimiter rateLimiter;
    private final RetryPolicy retryPolicy;
    private final LoadBalancer loadBalancer;

    @Autowired
    public ResilientServiceClient(RestTemplate restTemplate,
                                  CircuitBreaker circuitBreaker,
                                  RateLimiter rateLimiter,
                                  RetryPolicy retryPolicy,
                                  LoadBalancer loadBalancer) {
        this.restTemplate = restTemplate;
        this.circuitBreaker = circuitBreaker;
        this.rateLimiter = rateLimiter;
        this.retryPolicy = retryPolicy;
        this.loadBalancer = loadBalancer;
    }

    public <T> T callService(String serviceName, String endpoint, Class<T> responseType) {
        // 组合使用各种能力
        String key = serviceName + ":" + endpoint;

        if (!rateLimiter.allowRequest(key, 100)) {
            throw new RateLimitExceededException("Rate limit exceeded");
        }

        return circuitBreaker.execute(
            () -> retryPolicy.execute(() -> {
                ServiceInstance instance = loadBalancer.choose(serviceName);
                String url = buildUrl(instance, endpoint);
                return restTemplate.getForObject(url, responseType);
            }),
            () -> getFallbackResponse(responseType)
        );
    }

    private String buildUrl(ServiceInstance instance, String endpoint) {
        return "http://" + instance.getHost() + ":" + instance.getPort() + endpoint;
    }

    private <T> T getFallbackResponse(Class<T> responseType) {
        // 返回兜底响应
        return null;
    }
}
```

### 3.2 配置管理的组合 
```java
// 配置源接口
public interface ConfigSource {
    String getValue(String key);
    boolean containsKey(String key);
}

// 具体配置源
@Component
@Primary
public class EnvironmentConfigSource implements ConfigSource {
    @Override
    public String getValue(String key) {
        return System.getenv(key);
    }

    @Override
    public boolean containsKey(String key) {
        return System.getenv(key) != null;
    }
}

@Component
public class DatabaseConfigSource implements ConfigSource {
    @Override
    public String getValue(String key) {
        // 从数据库获取配置
        return null;
    }

    @Override
    public boolean containsKey(String key) {
        // 检查数据库中是否存在配置
        return false;
    }
}

@Component
public class RemoteConfigSource implements ConfigSource {
    @Override
    public String getValue(String key) {
        // 从远程配置中心获取
        return null;
    }

    @Override
    public boolean containsKey(String key) {
        // 检查远程配置中心
        return false;
    }
}

// 配置管理器组合多个配置源
@Service
public class CompositeConfigService {

    private final List<ConfigSource> configSources;

    @Autowired
    public CompositeConfigService(List<ConfigSource> configSources) {
        // 按优先级排序：环境变量 > 数据库 > 远程配置
        this.configSources = configSources.stream()
        .sorted((a, b) -> {
            if (a instanceof EnvironmentConfigSource) return -1;
            if (b instanceof EnvironmentConfigSource) return 1;
            if (a instanceof DatabaseConfigSource) return -1;
            if (b instanceof DatabaseConfigSource) return 1;
            return 0;
        })
        .collect(Collectors.toList());
    }

    public String getConfig(String key) {
        for (ConfigSource source : configSources) {
            if (source.containsKey(key)) {
                return source.getValue(key);
            }
        }
        throw new ConfigNotFoundException("Config not found: " + key);
    }

    // 动态添加新的配置源
    public void addConfigSource(ConfigSource configSource, int priority) {
        configSources.add(priority, configSource);
    }
}
```

## 4. 最佳实践场景 
### 4.1 模板方法模式的组合实现 
```java
// 使用组合替代模板方法模式中的继承
public interface Step<T, R> {
    R execute(T input);
}

// 具体步骤
@Component
public class ValidationStep implements Step<Order, ValidationResult> {
    @Override
    public ValidationResult execute(Order order) {
        // 验证逻辑
        return new ValidationResult(true);
    }
}

@Component
public class PricingStep implements Step<Order, PricingResult> {
    @Override
    public PricingResult execute(Order order) {
        // 定价逻辑
        return new PricingResult(BigDecimal.valueOf(100));
    }
}

@Component
public class PersistenceStep implements Step<Order, Void> {
    @Override
    public Void execute(Order order) {
        // 持久化逻辑
        return null;
    }
}

// 流程编排器组合各个步骤
@Service
public class OrderProcessingPipeline {

    private final List<Step<?, ?>> steps;

    @Autowired
    public OrderProcessingPipeline(List<Step<?, ?>> steps) {
        this.steps = steps;
    }

    @SuppressWarnings("unchecked")
    public OrderResult process(Order order) {
        Object context = order;

        for (Step step : steps) {
            if (step instanceof Step) {
                context = ((Step<Order, ?>) step).execute((Order) context);

                // 如果某步失败，可以中断流程
                if (context instanceof ValidationResult && !((ValidationResult) context).isValid()) {
                    return OrderResult.failure("Validation failed");
                }
            }
        }

        return OrderResult.success((Order) context);
    }

    // 动态添加步骤
    public void addStep(Step<?, ?> step) {
        steps.add(step);
    }
}
```

### 4.2 装饰器模式的组合应用 
```java
// 基础服务接口
public interface DataService {
    String fetchData(String key);
}

// 基础实现
@Service
public class BasicDataService implements DataService {
    @Override
    public String fetchData(String key) {
        return "Basic data for: " + key;
    }
}

// 装饰器 - 添加缓存功能
@Service
public class CachingDataService implements DataService {

    private final DataService delegate;
    private final Cache cache;

    public CachingDataService(DataService delegate, Cache cache) {
        this.delegate = delegate;
        this.cache = cache;
    }

    @Override
    public String fetchData(String key) {
        String cacheKey = "data:" + key;
        String cached = (String) cache.get(cacheKey);

        if (cached != null) {
            return cached;
        }

        String data = delegate.fetchData(key);
        cache.put(cacheKey, data);
        return data;
    }
}

// 装饰器 - 添加日志功能
@Service
public class LoggingDataService implements DataService {

    private final DataService delegate;
    private final Logger logger;

    public LoggingDataService(DataService delegate, Logger logger) {
        this.delegate = delegate;
        this.logger = logger;
    }

    @Override
    public String fetchData(String key) {
        logger.log("Fetching data for key: " + key);
        long start = System.currentTimeMillis();

        try {
            String result = delegate.fetchData(key);
            logger.log("Successfully fetched data for key: " + key);
            return result;
        } finally {
            long duration = System.currentTimeMillis() - start;
            logger.log("Data fetch took: " + duration + "ms");
        }
    }
}

// 使用组合的装饰器链
@Service
public class DataServiceFactory {

    @Autowired
    private BasicDataService basicService;
    @Autowired
    private Cache cache;
    @Autowired
    private Logger logger;

    public DataService createDataService(boolean enableCaching, boolean enableLogging) {
        DataService service = basicService;

        if (enableCaching) {
            service = new CachingDataService(service, cache);
        }

        if (enableLogging) {
            service = new LoggingDataService(service, logger);
        }

        return service;
    }
}
```

## 5. 优势总结 
1. **灵活性**：可以在运行时动态组合不同的功能
2. **松耦合**：组件之间通过接口交互，不直接依赖具体实现
3. **可测试性**：容易模拟和替换组件进行测试
4. **可维护性**：修改一个组件不会影响其他组件
5. **符合开闭原则**：新增功能通过添加新组件而非修改现有代码
6. **避免继承的缺点**：避免菱形继承、脆弱基类等问题

## 6. 实践建议 
1. **识别"has-a"关系时使用组合而非继承**
2. **通过Spring的依赖注入管理组件生命周期**
3. **使用接口定义组件契约**
4. **合理设计组件的粒度**
5. **利用Java 8+的函数式接口增强组合能力**

```java
// 使用函数式接口增强组合
@Service
public class FunctionalPipelineService {

    public <T, R> Function<T, R> composeFunctions(List<Function<T, R>> functions) {
        return functions.stream()
        .reduce(Function.identity(), Function::andThen);
    }

    public void exampleUsage() {
        Function<Order, Order> pipeline = composeFunctions(Arrays.asList(
            this::validateOrder,
            this::calculatePrice,
            this::applyDiscounts,
            this::saveOrder
        ));

        Order result = pipeline.apply(new Order());
    }

    private Order validateOrder(Order order) { return order; }
    private Order calculatePrice(Order order) { return order; }
    private Order applyDiscounts(Order order) { return order; }
    private Order saveOrder(Order order) { return order; }
}
```

在SpringBoot/SpringCloud中，合成复用原则是构建灵活、可维护微服务架构的基石。Spring框架本身的依赖注入机制就是CRP的典型应用，通过组合各种Bean来构建复杂的应用功能。

