---
cover: https://image.acg.lol/file/2025/11/09/reimu-4.jpg
title: 关于构造器和建造者模式
date: 2025-11-15 16:20:00
categories: Java编程语言
excerpt: 基于代码：`Computer` 类 + 内部 `Builder` 静态类，一句话优雅的构建对象，提升可读性和编码效率。
---

# Java 构造器与建造者模式复习文档  
**基于代码：`Computer` 类 + 内部 `Builder` 静态类**

---

## 一、核心知识点回顾

| 知识点 | 说明 |
|------|------|
| **构造器（Constructor）** | 用于创建对象并初始化实例变量 |
| **私有构造器** | 防止外部直接 `new`，强制通过特定方式创建对象 |
| **静态内部类** | `Builder` 是 `Computer` 的静态内部类，可独立使用 |
| **建造者模式（Builder Pattern）** | 一种**创建型设计模式**，用于构造复杂对象 |

---

## 二、代码解析：`Computer` 类

```java
public class Computer {
    private String cpu;
    private String memory;
    private String storage;
    private String graphics;

    // 私有构造函数 —— 只能由 Builder 调用
    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.storage = builder.storage;
        this.graphics = builder.graphics;
    }

    // 静态内部类 Builder
    public static class Builder {
        // 与外部类相同的字段（可选配置）
        private String cpu;
        private String memory;
        private String storage;
        private String graphics;

        // 链式调用方法（返回 this）
        public Builder cpu(String cpu) {
            this.cpu = cpu;
            return this;
        }
        public Builder memory(String memory) {
            this.memory = memory;
            return this;
        }
        public Builder storage(String storage) {
            this.storage = storage;
            return this;
        }
        public Builder graphics(String graphics) {
            this.graphics = graphics;
            return this;
        }

        // 构建最终对象
        public Computer build() {
            return new Computer(this);
        }
    }
}
```

---

## 三、建造者模式（Builder Pattern）详解

### 1. **定义**
> 将一个**复杂对象的构造过程**与它的**表示分离**，使得同样的构建过程可以创建不同的表示。

### 2. **适用场景**
- 对象有**多个可选参数**
- 需要**保证对象创建的顺序或完整性**
- 避免**构造函数参数过多**（望而生畏）
- 希望创建**不可变对象**

---

### 3. **建造者模式结构图（简化版）**

```
[Client]
   ↓
[Builder] → build() → [Product]
   ↑             ↑
[ConcreteBuilder]  [Director]（可选）
```

在本例中：
- `Computer` 是 **Product**
- `Builder` 是 **Concrete Builder**
- 无 `Director`（直接由客户端控制）

---

## 四、使用示例（推荐写法）

```java
public class Main {
    public static void main(String[] args) {
        Computer gamingPC = new Computer.Builder()
            .cpu("Intel i9-13900K")
            .memory("32GB DDR5")
            .storage("1TB NVMe SSD")
            .graphics("RTX 4090")
            .build();

        // 简配办公电脑
        Computer officePC = new Computer.Builder()
            .cpu("Intel i5")
            .memory("16GB")
            .build();  // storage 和 graphics 可选不填
    }
}
```

> **优点**：
> - 参数顺序随意
> - 可选参数清晰
> - 代码可读性强
> - 支持链式调用

---

## 五、为什么用 **私有构造器 + Builder**？

| 问题 | 传统构造器 | Builder 模式 |
|------|-----------|--------------|
| 参数太多 | `new Computer(a,b,c,d)` | 链式设置 |
| 可选参数 | 多个重载构造器 | 统一一个 Builder |
| 不可变对象 | 难保证 | 所有字段 `final` + Builder 构造 |
| 可读性 | 差 | 极佳 |

---

## 六、进阶：让 `Computer` 成为不可变类

```java
public class Computer {
    private final String cpu;
    private final String memory;
    private final String storage;
    private final String graphics;

    private Computer(Builder builder) {
        this.cpu = builder.cpu;
        this.memory = builder.memory;
        this.storage = builder.storage;
        this.graphics = builder.graphics;
    }
    // 只提供 getter，无 setter
    public String getCpu() { return cpu; }
    // ... 其他 getter
}
```

> **线程安全 + 防御性编程首选**

---

## 七、常见面试题

| 问题 | 答案要点 |
|------|--------|
| 什么是建造者模式？ | 分离构造与表示，支持复杂对象灵活创建 |
| 为什么构造器是 `private`？ | 强制使用 `Builder`，控制对象创建方式 |
| 为什么 `Builder` 是静态内部类？ | 可访问外部类私有构造器，且不依赖外部类实例 |
| 与工厂模式的区别？ | 建造者关注**构造过程**，工厂关注**返回产品** |
| Lombok `@Builder` 能替代吗？ | 可以，但理解手写原理更重要 |

---

## 八、一句话总结

> **建造者模式 = 私有构造器 + 静态 Builder 类 + 链式方法 + build() 构建**  
> 解决：**参数多、可选、顺序乱、不可变** 等构造函数痛点。

---

**建议背诵口诀**：
> **“对象复杂别硬造，Builder 一步步来搞；  
> 私有构造不让 new，链式调用真优雅！”**

---