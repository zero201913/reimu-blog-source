---
cover: https://image.acg.lol/file/2025/11/09/reimu-13.jpg
title: 手写Bean依赖注入容器：模拟Spring IoC核心原理
date: 2026-1-1 09:30:00
categories: 框架原理
excerpt: 本文详细介绍了如何实现一个轻量级的Java Bean Factory（依赖注入容器），模拟Spring IoC容器的核心原理，包括组件自动扫描、多方式依赖注入、仓库接口动态代理、基于注解的查询解析等核心功能，帮助开发者理解依赖注入的底层实现机制。
---

# 手写Bean Factory 轻量级依赖注入容器

## 一、项目概述
本项目实现了一个轻量级的Java Bean Factory（依赖注入容器），核心目标是模拟Spring IoC容器的核心原理，具备**组件自动扫描、多方式依赖注入、仓库接口动态代理、基于注解的查询解析**等能力，并通过Java Stream API模拟数据库查询操作，完整展现了轻量级依赖注入容器的设计与实现逻辑。
## 二、核心环境配置
### 1. 项目基础结构
```
bean-factory-demo/
├── .gitignore
├── README.md
├── pom.xml          # Maven依赖配置
├── .idea/           # IDE配置文件
└── src/main/java/cn/zero/
    ├── annotation/  # 自定义注解定义（核心扩展点）
    ├── factory/     # Bean工厂核心实现（容器核心）
    ├── model/       # 数据模型（业务实体）
    ├── repository/  # 数据访问层（接口+注解查询）
    ├── service/     # 业务逻辑层（Bean组件）
    └── test/        # 测试类（验证容器功能）
```

### 2. Maven依赖（核心推测）
项目聚焦纯Java原生实现+基础依赖，无复杂框架依赖：
- JDK 8+（支撑Lambda、Stream API、注解反射、动态代理）；
- 无额外Spring等框架依赖，完全自定义实现IoC核心逻辑。

## 三、核心功能模块与实现方式
### 1. 自定义注解系统（核心扩展点）
| 注解名称 | 作用目标 | 核心功能 | 关键属性 |
|----------|----------|----------|----------|
| @Component | 类（TYPE） | 标记类为Bean组件，触发容器自动扫描并创建实例 | value：可选，指定Bean名称（默认类名首字母小写） |
| @Autowired | 字段、构造函数、方法 | 标记依赖注入点，触发容器自动注入依赖 | required：默认true，依赖必须存在（否则抛异常） |
| @Query | 方法（METHOD） | 为仓库接口方法定义查询语句，模拟SQL查询 | value：查询语句（如`SELECT u FROM User u WHERE u.age > :age`） |

#### 注解实现共性：
- 保留策略：`RetentionPolicy.RUNTIME`（运行时可通过反射获取）；
- 文档化：`@Documented`（生成文档时包含注解说明）。

### 2. BeanFactory 核心容器（核心实现）
#### 2.1 核心数据结构
| 变量名 | 类型 | 核心作用 |
|--------|------|----------|
| beans | `ConcurrentHashMap<String, Object>` | 存储所有Bean实例，键=Bean名称，值=Bean实例（线程安全） |
| sampleData | `ConcurrentHashMap<Class<?>, List<?>>` | 存储模拟数据库的示例数据，支撑查询功能（键=数据模型类，值=模拟数据列表） |

#### 2.2 初始化流程（核心逻辑）
```java
private void initialize() {
    // 1. 初始化模拟数据（填充sampleData）
    initializeSampleData();
    // 2. 扫描指定包下所有类
    List<Class<?>> allClasses = getClassesInPackage(basePackage);
    
    // 3. 优先创建仓库接口代理（依赖前置）
    List<Class<?>> repositoryInterfaces = allClasses.stream()
            .filter(clazz -> clazz.isInterface() && clazz.getName().endsWith("Repository"))
            .collect(Collectors.toList());
    for (Class<?> intf : repositoryInterfaces) {
        Object proxy = createProxy(intf); // 动态代理创建仓库接口实例
        beans.put(getBeanName(intf), proxy); // 代理实例存入beans容器
    }
    
    // 4. 创建@Component注解标记的组件实例（业务Bean）
    List<Class<?>> componentClasses = allClasses.stream()
            .filter(clazz -> !clazz.isInterface() && clazz.isAnnotationPresent(Component.class))
            .collect(Collectors.toList());
    // （注：完整逻辑含实例化、依赖注入、存入beans容器）
}
```
初始化核心步骤拆解：
1. **数据初始化**：`initializeSampleData()` 填充模拟数据库数据到`sampleData`；
2. **包扫描**：`getClassesInPackage(basePackage)` 扫描指定包下所有类，为后续组件识别做准备；
3. **仓库代理优先创建**：
   - 筛选所有以`Repository`结尾的接口；
   - 通过`createProxy(intf)`创建动态代理实例，存入`beans`容器（保证业务Bean依赖注入时仓库已存在）；
4. **业务Bean创建**：筛选`@Component`注解的非接口类，完成实例化+依赖注入后存入`beans`容器。

#### 2.3 核心能力实现
| 能力名称 | 实现方式 | 核心逻辑 |
|----------|----------|----------|
| 组件扫描 | 反射+包扫描 | 通过类加载器扫描指定包下所有类，筛选`@Component`注解类/`Repository`接口 |
| 依赖注入 | 反射+@Autowired注解 | 实例化Bean后，通过反射遍历字段/构造函数/方法，识别`@Autowired`注解，从`beans`容器中获取依赖并注入 |
| 动态代理（仓库接口） | JDK动态代理 | 对`Repository`接口生成代理类，解析`@Query`注解的查询语句，结合`sampleData`通过Stream API执行模拟查询 |
| Bean获取 | 名称/类型映射 | 通过`getBeanName(Class<?> type)`将Bean类型转换为名称，从`beans`集合中获取实例（支持按类型获取） |

### 3. 业务层与数据层适配
#### 3.1 数据模型（model）
- 核心类：`User.java`（用户模型），作为模拟查询的基础数据结构；
- 作用：封装业务数据，支撑`sampleData`模拟数据存储和`@Query`查询解析。

#### 3.2 数据访问层（repository）
- 核心接口：`UserRepository.java`（用户仓库接口）；
- 设计特点：无实现类，通过`BeanFactory`动态代理生成实例；
- 核心能力：方法上标注`@Query`注解，定义查询规则，代理类解析注解并执行Stream模拟查询。

#### 3.3 业务逻辑层（service）
- 核心类：`UserService.java`（用户服务类）；
- 设计特点：标注`@Component`注解，触发容器自动实例化；
- 核心能力：通过`@Autowired`注入`UserRepository`代理实例，调用仓库方法完成业务逻辑。

## 四、核心技术栈与设计思想
### 1. 核心技术栈
- 反射（java.lang.reflect）：实现注解解析、类扫描、实例化、依赖注入；
- JDK动态代理（java.lang.reflect.Proxy）：为仓库接口生成动态代理实例，实现无实现类的查询逻辑；
- Java Stream API：模拟数据库查询（解析`@Query`语句后，通过Stream过滤/匹配`sampleData`数据）；
- 并发容器（ConcurrentHashMap）：保证Bean容器和模拟数据的线程安全；
- 自定义注解：扩展容器能力，对标Spring注解设计思路。

### 2. 核心设计思想
- 控制反转（IoC）：Bean的创建、依赖注入由容器（BeanFactory）管理，而非业务类自行创建；
- 组件化：通过`@Component`标记业务类，实现组件化管理，降低耦合；
- 面向接口编程：仓库层仅定义接口，通过动态代理实现，解耦接口与实现；
- 约定优于配置：默认Bean名称为类名首字母小写、Repository接口以固定后缀命名，减少配置成本；
- 分层设计：注解层→容器层→数据层→业务层，职责单一，分层清晰。

## 五、测试验证
- 核心测试类：`BeanFactoryTest.java`；
- 测试目标：验证BeanFactory的组件扫描、依赖注入、仓库查询等核心功能；
- 测试逻辑：初始化BeanFactory，获取UserService实例，调用业务方法，验证查询结果是否符合`@Query`定义规则。

## 六、项目价值与复盘要点
### 1. 项目价值
- 原理级实现：完整模拟Spring IoC容器核心逻辑，理解依赖注入、动态代理、注解解析的底层实现；
- 轻量化设计：无框架依赖，聚焦核心逻辑，便于学习和扩展；
- 对标Spring：注解设计、容器思想与Spring高度契合，降低Spring源码学习门槛。

### 2. 复盘关键要点
1. 容器初始化顺序：仓库代理优先创建的原因（保证业务Bean注入时依赖已存在）；
2. 动态代理核心：仓库接口代理类如何解析`@Query`注解并结合Stream执行查询；
3. 依赖注入实现：`@Autowired`支持字段/构造函数/方法注入的反射逻辑差异；
4. 线程安全：使用ConcurrentHashMap的设计考量（多线程场景下Bean容器的安全性）；
5. 扩展方向：可参考Spring扩展`@Scope`（作用域）、`@Qualifier`（限定符）等注解，丰富容器能力。


### 3. 项目链接
- 项目仓库：[https://github.com/zero201913/bean-factory-demo](https://github.com/zero201913/bean-factory-demo)
- 项目文档：[https://github.com/zero201913/bean-factory-demo/blob/main/README.md](https://github.com/zero201913/bean-factory-demo/blob/main/README.md)

