---
cover: https://image.acg.lol/file/2025/11/09/reimu-10.jpg
title: 里氏替换原则详解
date: 2025-11-16 8:30:00
categories: 设计模式
excerpt: 子类重写父类方法时，访问修饰符可以更宽松，但不能更严格。这遵循里氏替换原则。
---


```markdown
# 里氏替换原则（Liskov Substitution Principle, LSP）详解

> **“子类重写父类方法时，访问修饰符可以更宽松，但不能更严格。这遵循里氏替换原则。”**  
> —— 面向对象设计中的黄金法则之一

---

## 一、什么是里氏替换原则？

**里氏替换原则（Liskov Substitution Principle, LSP）** 是 SOLID 原则中的 **L**，由 Barbara Liskov 在 1987 年提出。

### 官方定义：
> **“子类型（subtype）必须能够替换其父类型（base type），而不破坏程序的正确性。”**

通俗来说：
> **“凡是能用父类的地方，子类也必须能正常工作，且行为符合预期。”**

---

## 二、为什么需要 LSP？

想象一个场景：

```ts
class Bird {
  fly() {
    console.log("我在飞！");
  }
}

class Penguin extends Bird {
  fly() {
    throw new Error("企鹅不会飞！");
  }
}

function makeBirdFly(bird: Bird) {
  bird.fly(); // 期望所有鸟都会飞
}

// 使用
makeBirdFly(new Bird());     // 正常
makeBirdFly(new Penguin());  // 抛错！违反预期
```

**问题**：`Penguin` 是 `Bird` 的子类，但它**不能替代** `Bird` 被正常使用。

这就**违反了里氏替换原则**。

---

## 三、访问修饰符的例子

> **子类重写父类方法时，访问修饰符可以更宽松，但不能更严格。**

### 正确示例（推荐）：

```java
class Animal {
  protected void eat() {
    System.out.println("吃东西");
  }
}

class Dog extends Animal {
  @Override
  public void eat() {  // protected → public，更宽松
    System.out.println("狗吃骨头");
  }
}
```

```java
void feedAnimal(Animal animal) {
  animal.eat(); // 编译器只知道是 Animal，调用 protected 方法？
}
```

注意：Java 中 `protected` 方法在**不同包的子类**中不可直接通过父类引用访问。

但更关键的是 **行为一致性**，而不仅是修饰符。

---

## 四、LSP 的核心：行为契约（Contract）

LSP 不仅仅是语法兼容，更是 **行为契约** 的延续。

| 父类承诺 | 子类必须遵守 |
|--------|------------|
| 前置条件 | 不应增强（不能要求更多） |
| 后置条件 | 不应削弱（必须保证更多或相等） |
| 不变式 | 必须保持 |

---

## 五、经典反例：正方形 vs 矩形

```ts
class Rectangle {
  protected width: number;
  protected height: number;

  setWidth(w: number) { this.width = w; }
  setHeight(h: number) { this.height = h; }
  getArea() { return this.width * this.height; }
}

class Square extends Rectangle {
  setWidth(w: number) {
    this.width = w;
    this.height = w;  // 强制相等
  }
  setHeight(h: number) {
    this.width = h;
    this.height = h;
  }
}

function testRectangle(rect: Rectangle) {
  rect.setWidth(5);
  rect.setHeight(4);
  console.log(rect.getArea() === 20); // 期望 true
}

// 测试
testRectangle(new Rectangle()); // true
testRectangle(new Square());    // 20 === 16? false! 违反 LSP
```

**结论**：`Square` **不是** `Rectangle` 的子类型（在行为上）！

---

## 六、如何遵守 LSP？—— 设计建议

### 1. **避免子类破坏父类行为**
```ts
// 错误：子类抛出父类未声明的异常
class Parent {
  parse(data: string) { /* 不抛异常 */ }
}

class Child extends Parent {
  parse(data: string) {
    if (!data) throw new Error("数据为空"); // 违反契约
  }
}
```

### 2. **子类不应增强前置条件**
```ts
class FileReader {
  read(path: string) { /* 读取任意文件 */ }
}

class SecureReader extends FileReader {
  read(path: string, password: string) { /* 多了一个参数 */ } // 错误！
}
```

### 3. **使用接口分离 + 依赖倒置**
```ts
interface Flyable {
  fly(): void;
}

interface Swimmable {
  swim(): void;
}

class Duck implements Flyable, Swimmable {
  fly() { console.log("鸭子飞"); }
  swim() { console.log("鸭子游"); }
}

class Penguin implements Swimmable {
  swim() { console.log("企鹅游"); }
}
```

---

## 七、LSP 与访问修饰符的关系（回到你的图片）

| 父类修饰符 | 子类允许 | 不允许 | 原因 |
|-----------|--------|-------|------|
| `public`     | `public` | `protected`, `private` | 不能降低可见性 |
| `protected`  | `protected`, `public` | `private` | 可以放宽，不能收紧 |
| `private`    | —— | —— | 不可重写 |

### 正确示例（Java）：
```java
class Parent {
  protected void method() { }
}

class Child extends Parent {
  @Override
  public void method() { } // 正确：protected → public
}
```

---

## 八、总结：LSP Checklist

| 检查项 | 是否合规 |
|--------|---------|
| 子类是否能**完全替代**父类？ | 是 |
| 子类是否**增强前置条件**？ | 否 |
| 子类是否**削弱后置条件**？ | 否 |
| 子类是否**收紧访问权限**？ | 否 |
| 子类是否**抛出未声明异常**？ | 否 |

---

## 九、参考资料

- 《Clean Architecture》 - Robert C. Martin
- [Liskov Substitution Principle - Wikipedia](https://en.wikipedia.org/wiki/Liskov_substitution_principle)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)

---

> **记住**：  
> **“继承不是为了复用代码，而是为了可替换性。”**  
> —— LSP 告诉我们：**设计时先问“能不能替换”，再问“能不能复用”。**

---

*本文适用于 Java、TypeScript、C# 等支持面向对象的语言。*
```

---