---
cover: https://image.acg.lol/file/2025/11/09/reimu-4.jpg
title: 里氏替换原则与依赖倒置原则在Spring中的应用
date: 2026-2-3 09:30:00
categories: 设计模式
excerpt: 本文详细介绍了里氏替换原则(LSP)和依赖倒置原则(DIP)在SpringBoot和SpringCloud中的应用实践，包括继承关系的正确使用、接口契约设计、依赖注入实现、服务间通信抽象等最佳实践，帮助开发者构建稳定、可扩展的系统架构。
---


# 里氏替换原则


里氏替换原则(Liskov Substitution Principle, LSP)是SOLID原则中的第三个原则，它由Barbara Liskov提出，规定：所有引用基类的地方必须能透明地使用其子类的对象。

## 核心概念
里氏替换原则的关键思想：  
• 子类必须完全实现父类的抽象方法

• 子类可以有自己的个性，但不得改变父类原有的行为契约

• 前置条件不能强化，后置条件不能弱化

• 子类不能抛出比父类更宽泛的异常

## SpringBoot中的应用方式
### 继承关系的正确使用
```java
// 基类定义契约
public abstract class PaymentService {
    /**
     * 支付金额必须大于0
     */
    public abstract PaymentResult pay(BigDecimal amount);
    
    /**
     * 验证支付参数
     */
    protected void validateAmount(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("支付金额必须大于0");
        }
    }
}

// 正确实现 - 遵守LSP
@Service
public class AlipayService extends PaymentService {
    @Override
    public PaymentResult pay(BigDecimal amount) {
        validateAmount(amount); // 调用父类验证
        // 支付宝特定逻辑
        return new PaymentResult(true, "支付宝支付成功");
    }
}

// 错误实现 - 违反LSP（示例）
@Service
public class WechatPayService extends PaymentService {
    @Override
    public PaymentResult pay(BigDecimal amount) {
        // 违反：没有调用父类验证，允许负金额
        if (amount == null) {
            throw new IllegalArgumentException("金额不能为空");
        }
        // 微信支付特定逻辑
        return new PaymentResult(true, "微信支付成功");
    }
}
```

### 基于接口的契约设计
```java
// 定义清晰的接口契约
public interface UserService {
    /**
     * 创建用户
     * @param userCreateRequest 用户信息，username不能为空，email格式必须正确
     * @return 创建的用户信息
     * @throws IllegalArgumentException 当参数不合法时抛出
     */
    UserDTO createUser(UserCreateRequest request);
}
// 符合LSP的实现
@Service
public class DefaultUserService implements UserService {
    @Override
    public UserDTO createUser(UserCreateRequest request) {
        if (request.getUsername() == null || request.getUsername().trim().isEmpty()) {
            throw new IllegalArgumentException("用户名不能为空");
        }
        // 正常业务逻辑
        return new UserDTO();
    }
}
// 不符合LSP的实现（示例）
@Service
public class LenientUserService implements UserService {
    @Override
    public UserDTO createUser(UserCreateRequest request) {
        // 违反：允许空用户名，改变了父类契约
        // 如果系统其他部分依赖username不为空，这里会导致问题
        return new UserDTO();
    }
}
```

## SpringCloud中的应用方式
### 3.1 微服务接口兼容性
```java
// 订单服务接口定义
public interface OrderService {
    /**
     * 创建订单
     * @param orderCreateCommand 订单创建命令
     * @return 订单ID
     * @throws BusinessException 业务异常，如库存不足、用户不存在等
     */
    Long createOrder(OrderCreateCommand orderCreateCommand);
}

// V1版本实现
@Service
public class OrderServiceV1 implements OrderService {
    @Override
    public Long createOrder(OrderCreateCommand command) {
        // V1逻辑：简单创建订单
        return 1L;
    }
}

// V2版本实现（扩展但不破坏原有契约）
@Service
@Primary
public class OrderServiceV2 implements OrderService {
    @Override
    public Long createOrder(OrderCreateCommand command) {
        // V2逻辑：增加优惠券计算，但仍保持原有契约
        // 仍然返回Long类型的订单ID
        // 仍然在库存不足时抛出BusinessException
        return 2L;
    }
}
```

### 3.2 Feign客户端与LSP
```java
// 商品服务Feign客户端接口
@FeignClient(name = "product-service", path = "/api/products")
public interface ProductServiceClient {
    
    @GetMapping("/{id}")
    ResponseEntity<ProductDTO> getProductById(@PathVariable Long id);
    
    @PostMapping
    ResponseEntity<ProductDTO> createProduct(@RequestBody ProductCreateRequest request);
}

// 实现类必须保持接口契约
@Component
public class ProductServiceFallback implements ProductServiceClient {
    
    @Override
    public ResponseEntity<ProductDTO> getProductById(Long id) {
        // 熔断降级实现，但返回类型必须一致
        ProductDTO fallback = new ProductDTO();
        fallback.setId(id);
        fallback.setName("商品暂时不可用");
        return ResponseEntity.ok(fallback);
    }
    
    @Override
    public ResponseEntity<ProductDTO> createProduct(ProductCreateRequest request) {
        // 必须保持相同的参数和返回类型
        throw new RuntimeException("服务暂时不可用");
    }
}
```



## 常见违反LSP的场景及解决方案
### 4.1 正方形不是长方形问题
```java
// 错误设计
class Rectangle {
    protected int width, height;
    
    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    public int getArea() { return width * height; }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int width) {
        super.setWidth(width);
        super.setHeight(width); // 违反：改变了父类行为
    }
    
    @Override
    public void setHeight(int height) {
        super.setWidth(height);
        super.setHeight(height); // 违反：改变了父类行为
    }
}

// 正确设计 - 使用组合代替继承
interface Shape {
    int getArea();
}

class Rectangle implements Shape {
    private int width, height;
    
    public void setWidth(int width) { this.width = width; }
    public void setHeight(int height) { this.height = height; }
    
    @Override
    public int getArea() { return width * height; }
}

class Square implements Shape {
    private int side;
    
    public void setSide(int side) { this.side = side; }
    
    @Override
    public int getArea() { return side * side; }
}
```

### 4.2 在Spring中的解决方案
```java
// 使用策略模式替代继承
@Service
public class ShapeCalculator {
    
    private Map<Class<?>, Function<Object, Integer>> calculators = new HashMap<>();
    
    public ShapeCalculator() {
        calculators.put(Rectangle.class, shape -> {
            Rectangle rect = (Rectangle) shape;
            return rect.getWidth() * rect.getHeight();
        });
        
        calculators.put(Square.class, shape -> {
            Square square = (Square) shape;
            return square.getSide() * square.getSide();
        });
    }
    
    public int calculateArea(Object shape) {
        Function<Object, Integer> calculator = calculators.get(shape.getClass());
        if (calculator == null) {
            throw new IllegalArgumentException("不支持的图形类型");
        }
        return calculator.apply(shape);
    }
}
```

## 最佳实践建议 
1. **优先使用组合而非继承**
2. **明确定义接口契约和前置/后置条件**
3. **使用@FunctionalInterface定义单一职责的函数接口**
4. **在微服务中使用API版本控制保持契约稳定**
5. **编写契约测试确保实现符合预期行为**

```java
// 契约测试示例
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
public class UserServiceContractTest implements UserService {
    
    private UserService implementation;
    
    @BeforeAll
    void setup() {
        // 注入待测实现
        implementation = new DefaultUserService();
    }
    
    @Test
    void shouldThrowExceptionWhenUsernameIsEmpty() {
        UserCreateRequest request = new UserCreateRequest();
        request.setUsername("");
        
        assertThrows(IllegalArgumentException.class, 
            () -> implementation.createUser(request));
    }
}
```

在SpringBoot/SpringCloud中遵循LSP原则，可以确保系统的稳定性和可扩展性，特别是在微服务这种分布式环境中，接口契约的稳定性至关重要。


# 依赖倒置


依赖倒置原则(Dependency Inversion Principle, DIP)是SOLID原则中的第四个原则，它规定：高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

## 1. 核心概念 
依赖倒置原则的两个关键表述：

1. **高层模块不应依赖低层模块，二者都该依赖抽象**
2. **抽象不应依赖细节，细节应依赖抽象**

核心思想：

+ 面向接口编程而非面向实现编程
+ 通过依赖注入解耦组件关系
+ 提高系统的灵活性和可测试性

## 2. SpringBoot中的应用方式 
### 2.1 依赖注入实现DIP 
```java
// 抽象定义 - 不依赖具体实现
public interface NotificationService {
    void sendNotification(String message, String recipient);
}

// 具体实现1
@Service
public class EmailNotificationService implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        System.out.println("发送邮件到: " + recipient + ", 内容: " + message);
    }
}

// 具体实现2
@Service
public class SmsNotificationService implements NotificationService {
    @Override
    public void sendNotification(String message, String recipient) {
        System.out.println("发送短信到: " + recipient + ", 内容: " + message);
    }
}

// 高层模块 - 依赖抽象而非具体实现
@Service
public class OrderService {

    private final NotificationService notificationService;

    // 通过构造器注入依赖 - Spring自动装配
    @Autowired
    public OrderService(NotificationService notificationService) {
        this.notificationService = notificationService;
    }

    public void createOrder(Order order) {
        // 业务逻辑...
        notificationService.sendNotification("订单创建成功", order.getCustomerEmail());
    }
}
```

### 2.2 配置化选择实现 
```java
@Configuration
public class NotificationConfig {

    @Bean
    @Primary
    @ConditionalOnProperty(name = "notification.type", havingValue = "email")
    public NotificationService emailNotificationService() {
        return new EmailNotificationService();
    }

    @Bean
    @ConditionalOnProperty(name = "notification.type", havingValue = "sms")
    public NotificationService smsNotificationService() {
        return new SmsNotificationService();
    }

    @Bean
    @ConditionalOnMissingBean
    public NotificationService defaultNotificationService() {
        return new EmailNotificationService(); // 默认实现
    }
}
```

### 2.3 使用@Qualifier精确控制 
```java
@Service
public class MultiChannelNotificationService {

    private final NotificationService emailService;
    private final NotificationService smsService;

    @Autowired
    public MultiChannelNotificationService(
        @Qualifier("emailNotificationService") NotificationService emailService,
        @Qualifier("smsNotificationService") NotificationService smsService) {
        this.emailService = emailService;
        this.smsService = smsService;
    }

    public void sendOrderConfirmation(Order order) {
        emailService.sendNotification("订单确认", order.getCustomerEmail());
        smsService.sendNotification("订单已确认", order.getCustomerPhone());
    }
}
```

## 3. SpringCloud中的应用方式 
### 3.1 服务间通信的抽象 
```java
// 抽象定义服务接口
public interface UserServiceClient {
    UserDTO getUserById(Long userId);
    List<UserDTO> getUsersByIds(List<Long> userIds);
}

// Feign实现
@FeignClient(name = "user-service", path = "/api/users")
public interface UserFeignClient extends UserServiceClient {
    
    @GetMapping("/{id}")
    @Override
    UserDTO getUserById(@PathVariable Long id);
    
    @GetMapping
    @Override
    List<UserDTO> getUsersByIds(@RequestParam List<Long> ids);
}

// 熔断降级实现
@Component
public class UserServiceFallback implements UserServiceClient {
    
    @Override
    public UserDTO getUserById(Long userId) {
        // 返回兜底数据或抛出异常
        return UserDTO.builder()
                .id(userId)
                .name("未知用户")
                .build();
    }
    
    @Override
    public List<UserDTO> getUsersByIds(List<Long> userIds) {
        return userIds.stream()
                .map(this::getUserById)
                .collect(Collectors.toList());
    }
}

// 高层服务 - 依赖抽象
@Service
public class OrderService {
    
    private final UserServiceClient userServiceClient;
    
    public OrderService(UserServiceClient userServiceClient) {
        this.userServiceClient = userServiceClient;
    }
    
    public OrderDTO createOrder(OrderCreateRequest request) {
        UserDTO user = userServiceClient.getUserById(request.getUserId());
        // 业务逻辑...
        return new OrderDTO();
    }
}
```

### 3.2 配置中心集成 
```java
// 抽象配置服务
public interface ConfigService {
    String getString(String key);
    Integer getInt(String key);
    Boolean getBoolean(String key);
}

// Nacos实现
@Service
@RefreshScope
public class NacosConfigService implements ConfigService {
    
    @Autowired
    private ConfigService nacosConfigManager;
    
    @Override
    public String getString(String key) {
        return nacosConfigManager.getProperty(key, String.class);
    }
    
    // 其他方法实现...
}

// Apollo实现
@Service
public class ApolloConfigService implements ConfigService {
    // Apollo特定实现
}

// 使用配置的组件
@Service
public class PaymentConfigService {
    
    private final ConfigService configService;
    
    public PaymentConfigService(ConfigService configService) {
        this.configService = configService;
    }
    
    public PaymentMethod getDefaultPaymentMethod() {
        String method = configService.getString("payment.default.method");
        return PaymentMethod.valueOf(method);
    }
}
```

## 4. 最佳实践场景 
### 4.1 工厂模式+依赖倒置 
```java
// 抽象工厂
public interface NotificationFactory {
    NotificationService createNotificationService();
}

// 具体工厂
@Component
public class EmailNotificationFactory implements NotificationFactory {
    @Override
    public NotificationService createNotificationService() {
        return new EmailNotificationService();
    }
}

@Component
public class SmsNotificationFactory implements NotificationFactory {
    @Override
    public NotificationService createNotificationService() {
        return new SmsNotificationService();
    }
}

// 工厂提供者
@Service
public class NotificationFactoryProvider {
    
    private final Map<String, NotificationFactory> factories;
    
    @Autowired
    public NotificationFactoryProvider(List<NotificationFactory> factoryList) {
        factories = factoryList.stream()
                .collect(Collectors.toMap(
                    factory -> factory.getClass().getSimpleName()
                        .replace("NotificationFactory", "")
                        .toLowerCase(),
                    Function.identity()
                ));
    }
    
    public NotificationService getNotificationService(String type) {
        NotificationFactory factory = factories.get(type.toLowerCase());
        if (factory == null) {
            throw new IllegalArgumentException("不支持的通知类型: " + type);
        }
        return factory.createNotificationService();
    }
}
```

### 4.2 事件驱动架构中的DIP 
```java
// 抽象事件
public interface DomainEvent {
    LocalDateTime getOccurredOn();
}

// 具体事件
public class OrderCreatedEvent implements DomainEvent {
    private final Long orderId;
    private final LocalDateTime occurredOn;
    
    public OrderCreatedEvent(Long orderId) {
        this.orderId = orderId;
        this.occurredOn = LocalDateTime.now();
    }
    
    @Override
    public LocalDateTime getOccurredOn() {
        return occurredOn;
    }
    
    public Long getOrderId() {
        return orderId;
    }
}

// 抽象事件处理器
public interface EventHandler<T extends DomainEvent> {
    void handle(T event);
    Class<T> getEventType();
}

// 具体事件处理器
@Component
public class OrderCreatedEventHandler implements EventHandler<OrderCreatedEvent> {
    
    @Override
    public void handle(OrderCreatedEvent event) {
        System.out.println("处理订单创建事件: " + event.getOrderId());
        // 发送通知、更新统计等业务逻辑
    }
    
    @Override
    public Class<OrderCreatedEvent> getEventType() {
        return OrderCreatedEvent.class;
    }
}

// 事件分发器 - 高层模块依赖抽象
@Service
public class EventDispatcher {
    
    private final Map<Class<?>, List<EventHandler<?>>> handlers = new ConcurrentHashMap<>();
    
    @Autowired
    public EventDispatcher(List<EventHandler<?>> eventHandlers) {
        for (EventHandler<?> handler : eventHandlers) {
            Class<?> eventType = handler.getEventType();
            handlers.computeIfAbsent(eventType, k -> new ArrayList<>()).add(handler);
        }
    }
    
    @SuppressWarnings("unchecked")
    public <T extends DomainEvent> void dispatch(T event) {
        List<EventHandler<?>> eventHandlers = handlers.getOrDefault(event.getClass(), Collections.emptyList());
        for (EventHandler handler : eventHandlers) {
            ((EventHandler<T>) handler).handle(event);
        }
    }
}
```

### 4.3 数据库访问层的抽象 
```java
// 抽象Repository
public interface UserRepository {
    Optional<User> findById(Long id);
    User save(User user);
    void deleteById(Long id);
}

// JPA实现
@Repository
public class JpaUserRepository implements UserRepository {
    
    @PersistenceContext
    private EntityManager entityManager;
    
    @Override
    public Optional<User> findById(Long id) {
        return Optional.ofNullable(entityManager.find(User.class, id));
    }
    
    // 其他方法实现...
}

// MyBatis实现
@Repository
public class MyBatisUserRepository implements UserRepository {
    
    @Autowired
    private UserMapper userMapper;
    
    @Override
    public Optional<User> findById(Long id) {
        return Optional.ofNullable(userMapper.selectById(id));
    }
    
    // 其他方法实现...
}

// 服务层依赖抽象
@Service
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public UserDTO getUserProfile(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException("用户不存在"));
        return convertToDTO(user);
    }
}
```

## 5. 优势总结 
1. **松耦合**：高层模块与低层模块解耦，便于独立演化
2. **可测试性**：容易进行单元测试，可以注入Mock对象
3. **可扩展性**：新增实现无需修改现有代码
4. **可维护性**：依赖关系清晰，代码结构稳定
5. **符合开闭原则**：通过新增实现扩展功能，无需修改抽象

在SpringBoot/SpringCloud中，依赖倒置原则通过Spring框架的依赖注入机制得到完美支持，使得构建灵活、可维护的微服务架构成为可能。Spring的IoC容器本身就是依赖倒置原则的经典实践。

