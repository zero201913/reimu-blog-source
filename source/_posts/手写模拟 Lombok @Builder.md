---
cover: https://image.acg.lol/file/2025/11/09/reimu-7.jpg
title: 手写模拟 Lombok @Builder
date: 2025-11-7 8:00:00
categories: Java框架
excerpt: Builder注解是开发中简化对象构建的常用工具，其核心价值在于自动生成链式构建器代码，减少重复编码。
---


Lombok的@Builder注解是开发中简化对象构建的常用工具，其核心价值在于自动生成链式构建器代码，减少重复编码。本文将从原理拆解、手动实现、核心对比三个维度，带你吃透@Builder注解的底层逻辑，为后期复习提供清晰参考。



## 一、@Builder注解核心功能拆解



要模拟@Builder，首先需明确其核心作用，确保手写版本与Lombok功能对齐：



1. 生成静态内部类Builder，包含目标类所有属性的成员变量。

2. 为Builder类生成属性对应的链式setter方法（方法名与属性名一致，返回Builder对象）。

3. 目标类生成私有无参构造器（避免外部直接实例化）。

4. 目标类生成public静态builder()方法，返回Builder实例。

5. Builder类生成build()方法，通过目标类的全参构造器创建目标对象并返回。



## 二、手写模拟@Builder的完整实现



### 1. 定义核心注解@MyBuilder



首先创建自定义注解，用于标记需要生成构建器的类：



```Java

```



### 2. 实现注解处理器（核心逻辑）



通过Java反射机制，在运行时为标记@MyBuilder的类动态生成Builder相关代码（实际Lombok基于编译期注解处理器，此处用反射模拟更易理解）：



```Java

```



### 3. 目标类使用示例



```Java

```



### 4. 测试验证



```Java

```



## 三、手写版本与Lombok @Builder的核心差异



|对比维度|手写模拟版本|Lombok @Builder|
|---|---|---|
|实现时机|运行时（反射/动态代理）|编译期（注解处理器APT）|
|侵入性|需显式定义全参构造器、Builder接口|零侵入，自动生成所有代码|
|性能|运行时反射有轻微性能损耗|编译期生成字节码，无运行时损耗|
|功能完整性|仅实现核心链式构建|支持@Builder.Default（默认值）、toBuilder（对象拷贝）等扩展功能|
|使用成本|需手动配合接口定义、构造器编写|仅需添加注解，开箱即用|


## 四、核心原理总结



1. **注解的作用**：@MyBuilder仅作为标记，告诉处理器“需要为该类生成构建器”。

2. **代码生成逻辑**：核心是动态创建包含目标类属性的Builder类，通过链式setter存储属性值，最终通过全参构造器实例化目标对象。

3. **Lombok的优化**：Lombok选择编译期生成代码，避免了反射的性能损耗，同时通过字节码操作自动补全构造器、Builder类等，降低使用成本。



## 五、复习重点与交付物提议



本次手写模拟的核心是理解“注解标记-代码生成-链式构建”的闭环，复习时需重点掌握Builder模式的设计思想、注解处理器的工作流程。



要不要我帮你整理一份**@Builder核心原理思维导图**？将注解作用、代码生成步骤、Lombok优化点等关键信息可视化，方便后续快速回顾。
> （注：文档部分内容可能由 AI 生成）